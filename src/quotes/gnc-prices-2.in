#!/usr/bin/perl -w

use strict;
use English;
use Finance::Quote;

## Simple program to get quotes and feed them back to gnucash.

## Modified by Paul Fenwick <pjf@cpan.org>, June 2000, to take
## advantage of new Finance::Quote features.

## Input (on standard input - one entry per line and one line per entry)
##
## (fetch "NYSE" "IBM")
## (fetch "nyse" "ibm" "axp")
## (fetch "nasdaq" "jdsu")
## (fetch "nasdaq" "CSCO" "jdsu")

## Output (on standard output, one output form per input line)

## Schemified version of finance-quote's output, so basically an alist
## of alists, as in the example below.  Only fields that this script
## knows about (and knows how to convert to scheme) are returned, so
## the conversion function will have to be updated whenever
## Finance::Quote changes.



## On error, result may be just #f, or errors may be stored with each
## quote as indicated in Finance::Quote.

## Exit status
##
## 0 - success
## non-zero - failure

# TODO:

# Is this safe?  Can we just double all backslashes and backslash
# escape all double quotes and get the right answer?

# Right now this is more inefficient than it needs to be.  We ask for
# each stock individually, but we should batch reqests to the same
# source.  Perhaps later...

my $exit_status = 0;

# Create a stockquote object.
my $quoter = Finance::Quote->new();

sub schemify_str {
  my($str) = @_;

  # Right now this is a hack.  We just make sure the outgoing string
  # has no double quotes in it by mangling them all to single quotes.
  # This is wrong, but it's better than letting dangerous strings
  # through.  We can always improve this later.

  # Have to do this because the perl-mode parser freaks out otherwise.
  my $dq = '"';
  my $sq = "'";

  $str =~ s/$dq/$sq/gmo;
  return $str;
}

my @lookup_items = ();

while(<>) {

  # This big ugly nasty thing just matches something like this

  # ("FOO" "BAR")

  # where, rougly speaking, whitespace is allowed almost everywhere,
  # this text constitutes the entire line, and the double-quotes and
  # parens shown are the only occurences of those characters allowed
  # in the line.

  # Have to do this because the perl-mode parser freaks out otherwise.
  my $dq = '"';

  my $security_name;
  my $quote_source_name;

  if($_ =~ m/^\s* \(\s* $dq ([^$dq]+) $dq \s* $dq([^$dq]+)$dq  \s*\)  \s*$/ox) {
    $security_name = $1;
    $quote_source_name = $2;
  } else {
    my $scm_str = schemify_str($_);
    print "(error bad-input-line \"Ignoring bad input line: $scm_str\")\n";
    $exit_status |= 1;
    # Yes this is ugly, but it really is what we mean here.
    next;
  }

  my %quote_data = $quoter->fetch($quote_source_name,$security_name);

  unless($quote_data{$quote_source_name,'success'}) {
    # We don't have to schemify the source or name - the regexp filtered it.
    print "(error quote-lookup-failed ";
    print "\"Lookup of $security_name at $quote_source_name failed.\")\n";
    $exit_status |= 1;
    next;
  }    

  my $security_price = $quote_data{$security_name, 'price'};
  my $quote_date = $quote_data{$security_name, 'date'};

  if(!$security_price) {
    # We don't have to schemify the source or name - the regexp filtered it.
    print "(error price-not-found " .
        "\"Couldn't find price for $security_name " .
            "in response from $quote_source_name.\")\n";
    $exit_status |= 1;
    next;
  }    

  ## We'll just let gnucash deal with the date...
  $quote_date = schemify_str($quote_date);

  ## Whew.  Finally.
  print "(quote";
  print " (name . \"$security_name\")";
  print " (date . \"$quote_date\")";
  print " (price . \"$security_price\")\n";
}

exit $exit_status;

__END__
