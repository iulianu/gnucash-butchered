#!@-PERL-@ -w
#
# FILE:
# gnc-prices
#
# FUNCTION:
# go out to the net, fetch prices for any securities,
# stocks/mutual funds in a GnuCash portfolio.
#
# HISTORY:
# Created by Linas Vepstas January 1999
# Updated by Paul Fenwick <pjf@cpan.org> to take advantage of
#   new Finance::Quote features. (June 2000)
# Updated by Steven Murdoch <sjmurdoch@linuxfan.com> to take
#   account of London stock prices being quoted in pence
#   by Yahoo Europe and improve behaviour in the case of no
#   Internet connection (July 2000)
#
# Copyright (c) 1999-2000 Linas Vepstas

use lib '@-GNC_PERLSHAREDIR-@';
use lib '@-GNC_PERLLIBDIR-@';

use Finance::Quote;
use gnucash;

# --------------------------------------------------
# @account_list = &account_flatlist ($account_group);
# This routine accepts a pointer to a group, returns 
# a flat list of all of the children in the group.

sub account_flatlist 
{
  my $grp = $_[0];
  my $naccts = gnucash::xaccGroupGetNumAccounts ($grp);
  my $n;
  my (@acctlist, @childlist);
  my $children;

  foreach $n (0..$naccts-1)
  {
    $acct = gnucash::xaccGroupGetAccount ($grp, $n);
    push (@acctlist, $acct);

    $children = gnucash::xaccAccountGetChildren ($acct);
    if ($children)
    {
      @childlist = &account_flatlist ($children);
      push (@acctlist, @childlist);
    }
  }

  return (@acctlist);
}

# --------------------------------------------------
# &checkprice ($account, $date, $price);
# This routine checks to see if the account has already stored a
# price for this day, returning 1 if yes and the price is the same
# as the one given, otherwise 0/undefined.

sub checkprice
{
  my $acct  = $_[0];
  my $dayte = $_[1];
  my $price = $_[2];
  my ($query, $datesecs, $earliest, $latest);
  my ($splitlist, $i, $split, $action, $pryce);
  my $retn_value = 0;

  $datesecs = gnucash::xaccScanDateS ($dayte);
  $earliest = $datesecs - 16*3600;        # subtract 16 hours
  $latest = $datesecs + 16*3600;          # add 16 hours
  $query = gnucash::xaccMallocQuery();
  gnucash::xaccQuerySetGroup($query, gnucash::xaccAccountGetParent($acct));
  gnucash::xaccQueryAddSingleAccountMatch ($query, $acct, $gnucash::QUERY_AND);
  gnucash::xaccQueryAddDateMatchTT ($query, $earliest, $latest,
                                    $gnucash::QUERY_AND);
  $splitlist = gnucash::xaccQueryGetSplits ($query);

  $i = 0;
  $split = gnucash::IthSplit ($splitlist, $i);
  while ($split && ($retn_value == 0))
  {
    $action = gnucash::xaccSplitGetAction ($split);
    $pryce = gnucash::xaccSplitGetSharePrice ($split);
    if (($action eq "Price") && ($price == $pryce)) { $retn_value = 1; }
    $i++;
    $split = gnucash::IthSplit ($splitlist, $i);
  }

  gnucash::xaccFreeQuery ($query);

  return $retn_value;
}

# --------------------------------------------------
# &setprice ($account, $date, $price);
# This routine stores the indicated price in the indicated account.
# Handy little utility avoids the usual hassle.

sub setprice 
{
  my $acct  = $_[0];
  my $dayte = $_[1];
  my $price = $_[2];
  my ($trans, $split);

  $trans = gnucash::xaccMallocTransaction();
  gnucash::xaccTransBeginEdit ($trans, 1);
  gnucash::xaccTransSetDescription ($trans, "Price");

  # Temporary hack until we get rid of this file
  gnucash::xaccTransSetDateToday ($trans);

  $split = gnucash::xaccTransGetSplit ($trans, 0);
  gnucash::xaccSplitSetSharePriceAndAmount ($split, $price, 0.0);
  gnucash::xaccSplitSetAction ($split, "Price");
  gnucash::xaccTransCommitEdit ($trans);

  gnucash::xaccAccountBeginEdit ($acct, 1);
  gnucash::xaccAccountInsertSplit ($acct, $split);
  gnucash::xaccAccountCommitEdit ($acct);

  return 1;
}

# --------------------------------------------------

die "Usage: $0 <gnucash-filename>" if $#ARGV < 0;

# open the file, read all of the accounts
print "Opening file $ARGV[0]\n";
$sess = gnucash::xaccMallocSession ();
gnucash::xaccSessionBegin ($sess, "file:".$ARGV[0]);
gnucash::xaccSessionLoad ($sess);
$grp = gnucash::xaccSessionGetGroup ($sess);

die "failed to read file $ARGV[0], maybe its locked? " if (! $grp);

# Create our quote object

my $quote = Finance::Quote->new();

# get a flat list of accounts in the file
@acctlist = &account_flatlist ($grp);

# loop over the accounts, look for stock and mutual funds.
foreach $acct (@acctlist)
{
  $name = gnucash::xaccAccountGetName ($acct);
  $type = gnucash::xaccAccountGetType ($acct);

  if (($type == $gnucash::STOCK) ||
      ($type == $gnucash::MUTUAL))
  {
    print "$name: ";

    $security = gnucash::xaccAccountGetSecurity ($acct);
    $accinfo = gnucash::xaccAccountGetAccInfo ($acct);
    $invacct = gnucash::xaccCastToInvAcct ($accinfo);

    if ($security eq "") 
    {
       print "unknown. skipping...\n";
       next;
    }
    if ($invacct)
    {
      $quotesrc = gnucash::xaccInvAcctGetPriceSrc ($invacct);
      unless ($quotesrc)
      {
        print "no quote source found\n";
        next;
      }

      undef $price;  # undef to make sure later if($price) not broken

      %quotes = $quote->fetch($quotesrc, $security);

      unless ($quotes{$security,'success'})
      {
      	print "Lookup of $quotesrc/$security failed";
	# Show the error if and only if there is an error message
	print ": $quotes{$security,'errormsg'}" if ($quotes{$security,'errormsg'});
        print "\n";
	next;
      }

      print "using $quotesrc\n";      
      
      $price = $quotes{$security,'price'};
      $dayte = $quotes {$security, "date"};
      $prodname = $quotes {$security, "name"};

      if ($price)
      {
        print "$name: $security $prodname last price = $price at $dayte\n";
        # This || construction will store the price if its not already 
        # stored (in the 28 hour period surrounding "dayte")
        &checkprice ($acct, $dayte, $price) ||
          &setprice ($acct, $dayte, $price);
      }
    }
  }
}

gnucash::xaccSessionSave ($sess);
gnucash::xaccSessionEnd ($sess);

## Local Variables:
## mode: perl
## End:
