#!@-PERL-@ -w
#
# FILE:
# gnc-prices
#
# FUNCTION:
# go out to the net, fetch prices for any securities,
# stocks/mutual funds in a GnuCash portfolio.
#
# HISTORY:
# Created by Linas Vepstas January 1999
# Updated by Paul Fenwick <pjf@cpan.org> to take advantage of
#   new Finance::Quote features. (June 2000)
# Updated by Steven Murdoch <sjmurdoch@linuxfan.com> to take
#   account of London stock prices being quoted in pence
#   by Yahoo Europe and improve behaviour in the case of no
#   Internet connection (July 2000)
#
# Copyright (c) 1999-2000 Linas Vepstas

use lib '@-GNC_PERLSHAREDIR-@';
use Quote;
use lib '@-GNC_PERLLIBDIR-@';
use gnucash;

# --------------------------------------------------
# @account_list = &account_flatlist ($account_group);
# This routine accepts a pointer to a group, returns 
# a flat list of all of the children in the group.

sub account_flatlist 
{
  my $grp = $_[0];
  my $naccts = gnucash::xaccGroupGetNumAccounts ($grp);
  my $n;
  my (@acctlist, @childlist);
  my $children;

  foreach $n (0..$naccts-1)
  {
    $acct = gnucash::xaccGroupGetAccount ($grp, $n);
    push (@acctlist, $acct);

    $children = gnucash::xaccAccountGetChildren ($acct);
    if ($children)
    {
      @childlist = &account_flatlist ($children);
      push (@acctlist, @childlist);
    }
  }

  return (@acctlist);
}

# --------------------------------------------------
# &checkprice ($account, $date, $price);
# This routine checks to see if the account has already stored a
# price for this day, returning 1 if yes and the price is the same
# as the one given, otherwise 0/undefined.

sub checkprice
{
  my $acct  = $_[0];
  my $dayte = $_[1];
  my $price = $_[2];
  my ($query, $datesecs, $earliest, $latest);
  my ($splitlist, $i, $split, $action, $pryce);
  my $retn_value = 0;

  $datesecs = gnucash::xaccScanDateS ($dayte);
  $earliest = $datesecs - 16*3600;        # subtract 16 hours
  $latest = $datesecs + 16*3600;          # add 16 hours
  $query = gnucash::xaccMallocQuery();
  gnucash::xaccQuerySetGroup($query, gnucash::xaccAccountGetParent($acct));
  gnucash::xaccQueryAddSingleAccountMatch ($query, $acct, $gnucash::QUERY_AND);
  gnucash::xaccQueryAddDateMatchTT ($query, $earliest, $latest,
                                    $gnucash::QUERY_AND);
  $splitlist = gnucash::xaccQueryGetSplits ($query);

  $i = 0;
  $split = gnucash::IthSplit ($splitlist, $i);
  while ($split && ($retn_value == 0))
  {
    $action = gnucash::xaccSplitGetAction ($split);
    $pryce = gnucash::xaccSplitGetSharePrice ($split);
    if (($action eq "Price") && ($price == $pryce)) { $retn_value = 1; }
    $i++;
    $split = gnucash::IthSplit ($splitlist, $i);
  }

  gnucash::xaccFreeQuery ($query);

  return $retn_value;
}

# --------------------------------------------------
# &setprice ($account, $date, $price);
# This routine stores the indicated price in the indicated account.
# Handy little utility avoids the usual hassle.

sub setprice 
{
  my $acct  = $_[0];
  my $dayte = $_[1];
  my $price = $_[2];
  my ($trans, $split);

  $trans = gnucash::xaccMallocTransaction();
  gnucash::xaccTransBeginEdit ($trans, 1);
  gnucash::xaccTransSetDescription ($trans, "Price");
  gnucash::xaccTransSetDateStr ($trans,$dayte);

  $split = gnucash::xaccTransGetSplit ($trans, 0);
  gnucash::xaccSplitSetSharePriceAndAmount ($split, $price, 0.0);
  gnucash::xaccSplitSetAction ($split, "Price");
  gnucash::xaccTransCommitEdit ($trans);

  gnucash::xaccAccountBeginEdit ($acct, 1);
  gnucash::xaccAccountInsertSplit ($acct, $split);
  gnucash::xaccAccountCommitEdit ($acct);

  return 1;
}

# --------------------------------------------------

die "Usage: $0 <gnucash-filename>" if $#ARGV < 0;

# open the file, read all of the accounts
print "Opening file $ARGV[0]\n";
$sess = gnucash::xaccMallocSession ();
$grp = gnucash::xaccSessionBeginFile ($sess,$ARGV[0]);

die "failed to read file $ARGV[0], maybe its locked? " if (! $grp);

# get a flat list of accounts in the file
@acctlist = &account_flatlist ($grp);

# loop over the accounts, look for stock and mutual funds.
foreach $acct (@acctlist)
{
  $name = gnucash::xaccAccountGetName ($acct);
  $type = gnucash::xaccAccountGetType ($acct);

  if (($type == $gnucash::STOCK) ||
      ($type == $gnucash::MUTUAL))
  {
    print "$name: ";

    $security = gnucash::xaccAccountGetSecurity ($acct);
    $accinfo = gnucash::xaccAccountGetAccInfo ($acct);
    $invacct = gnucash::xaccCastToInvAcct ($accinfo);

    if ($security eq "") 
    {
       print "unknown. skipping...\n";
       next;
    }
    if ($invacct)
    {
      $quotesrc = gnucash::xaccInvAcctGetPriceSrc ($invacct);
      unless ($quotesrc)
      {
        print "no quote source found\n";
        next;
      }

      undef $price;  # undef to make sure later if($price) not broken

      # assign to a list, beacuse if fetch fails assignment
      # to a hash will raise a warning, as it will return a one
      # element list. where the first element is undef
      @quotes_list = &Quote::fetch($quotesrc, $security);

      # if and only if  there really is information then assign to the hash
      %quotes = @quotes_list if $quotes_list[0];

      # the fetch is OK if and only if information is returned AND
      # it is maked as a success
      # The first condition is needed becasue if no information 
      # returned then %quotes is uninitialized and perl will raise a warning
      unless ($quotes_list[0] && $quotes{$security,'success'})
      {
      	print "Lookup of $quotesrc/$security failed";
	# Show the error if and only if there is an error message
	print ": $quotes{$security,'errormsg'}" if ($quotes{$security,'errormsg'});
        print "\n";
	next;
      }

      print "using $quotesrc\n";      
      
      $price = $quotes{$security,'price'};
      $dayte = $quotes {$security, "date"};
      $prodname = $quotes {$security, "name"};

      if ($price)
      {
	# if and only if the price is served by Yahoo Europe AND is dealt on
	# the London stock market then the price will be given in pence. So to
	# convert this into GBP divide the price by 100 before storing the new price.
	$price/=100 if (($security=~/.L$/i) && ($quotesrc eq 'YAHOO_EUROPE'));

        print "$name: $security $prodname last price = $price at $dayte\n";
        # This || construction will store the price if its not already 
        # stored (in the 28 hour period surrounding "dayte")
        &checkprice ($acct, $dayte, $price) ||
          &setprice ($acct, $dayte, $price);
      }
    }
  }
}

gnucash::xaccSessionSave ($sess);
gnucash::xaccSessionEnd ($sess);

## Local Variables:
## mode: perl
## End:
