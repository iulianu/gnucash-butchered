#!@-PERL-@ -w
######################################################################
### price-quote-helper - present a scheme interface to Finance::Quote
### Copyright 2001 Rob Browning <rlb@cs.utexas.edu>
### 
### This program is free software; you can redistribute it and/or    
### modify it under the terms of the GNU General Public License as   
### published by the Free Software Foundation; either version 2 of   
### the License, or (at your option) any later version.              
###                                                                  
### This program is distributed in the hope that it will be useful,  
### but WITHOUT ANY WARRANTY; without even the implied warranty of   
### MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    
### GNU General Public License for more details.                     
###                                                                  
### You should have received a copy of the GNU General Public License
### along with this program# if not, contact:
###
### Free Software Foundation           Voice:  +1-617-542-5942
### 59 Temple Place - Suite 330        Fax:    +1-617-542-2652
### Boston, MA  02111-1307,  USA       gnu@gnu.org
######################################################################

use lib '@-PERLINCL-@';

use strict;
use English;
use FileHandle;
use Date::Manip;
use Finance::Quote;

# Input: (on standard input - one entry per line and one line per
# entry, and double quotes must only be delimiters, not string
# content -- remember, we don't have a real scheme parser on the perl
# side :>).
#
# (fetch "NYSE" "IBM")
# (fetch "NYSE" "IBM" "AXP")
# (fetch "NASDAQ" "JDSU")
# (fetch "NASDAQ" "CSCO" "JDSU")
#

# Output (on standard output, one output form per input line):

# Schemified version of finance-quote's output, basically an alist of
# alists, as in the example below.  Right now, the only a few fields
# that this script knows about (and knows how to convert to scheme)
# are returned, so the conversion function will have to be updated
# whenever Finance::Quote changes.  Right now, you'll get symbol,
# utc, and last, as here:
#
#  $ echo '(fetch "NASDAQ" "CSCO")' | ./price-quote-helper
#  (("CSCO" (symbol . "CSCO") (utc . 982709400) (last . 26.5625))
#   ("JDSU" (symbol . "JDSU") (utc . 982709400) (last . 33.0625)))

# On error, result may be just #f, or errors may be stored with each
# quote as indicated in Finance::Quote.  Also, whenever the
# conversion fails, the field will have the value 'failed-conversion,
# and accordingly this symbol will never be a legitimate conversion.

# Exit status
#
# 0 - success
# non-zero - failure

sub schemify_string {
  my($str) = @_;

  if(!$str) { return "failed-conversion"; }

  # FIXME: Is this safe?  Can we just double all backslashes and backslash
  # escape all double quotes and get the right answer?

  # double all backslashes.
  my $bs = "\\";
  $str =~ s/$bs$bs/$bs$bs/gmo;

  # escape all double quotes.
  # Have to do this because the perl-mode parser freaks out otherwise.
  my $dq = '"';
  $str =~ s/$dq/$bs$dq/gmo;
  return '"' . $str . '"';
}

sub schemify_boolean {
  my($bool) = @_;

  if($bool) {
    return "#t";
  } else {
    return "#f";
  }
}

sub schemify_num {
  my($numstr) = @_;
  # This is for normal numbers, not the funny ones like "2.346B".
  # For now we don't need to do anything.

  if(!$numstr) { return "failed-conversion"; }
  
  if($numstr =~ /^\s*(\d+(\.\d+)?)$/o) {
    return $1;
  } else {
    return "failed-conversion";
  }
}

sub schemify_date {
  # return the date in epoch seconds.
  my ($datestr) = @_;

  my $date = ParseDate($datestr);
  my $result = UnixDate($date, "%s");
  if($result !~ /^(\+|-)?\d+$/) {
    $result = "failed-conversion";
  }
  return("$result");
}

# sub schemify_range {
#   #convert range in form ``num1 - num2'' to ``(num1 num2)''.
# }

sub get_quote_utc {
  # return the date in utc epoch seconds.
  my ($item, $timezone, $quotehash) = @_;

  if(!$timezone) { return "failed-conversion"; }

  my $datestr = $$quotehash{$item, 'date'};
  my $timestr = $$quotehash{$item, 'time'};

  if(!$datestr) {
    return "failed-conversion";
  }
  my $parsestr = $datestr;
  if($timestr) {
    $parsestr .= " $timestr";
  }

  my $date = Date_ConvTZ(ParseDate($parsestr), $timezone, 'UTC');
  
  my $result = UnixDate($date, "%s");
  if($result !~ /^(\+|-)?\d+$/) {
    $result = "failed-conversion";
  }
  return $result;
}

sub schemify_quote {
  my($itemname, $quotehash, $indentlevel, $timezone) = @_;
  my $scmname = schemify_string($itemname);
  my $quotedata = "";
  my $field;
  my $data;

  $field = 'symbol';
  $data = schemify_string($$quotehash{$itemname, $field});
  $quotedata .= "($field . $data)";

  $field = 'utc';
  $data = get_quote_utc($itemname, $timezone, $quotehash);
  $quotedata .= " ($field . $data)";

  $field = 'last';
  $data = schemify_num($$quotehash{$itemname, $field});
  $quotedata .= " ($field . $data)";

  return "($scmname $quotedata)";
}

sub schemify_quotes {
  my($items, $quotehash, $timezone) = @_;
  my $resultstr = "";
  my $i;
  my $separator = "";

  # we have to pass in @$items because Finance::Quote just uses the
  # mangled "$name$field string as the key, so there's no way (I know
  # of) to find out which stocks are in a given quotehash, just given
  # the quotehash.

  foreach $i (@$items) {
    $resultstr .= $separator . schemify_quote($i, $quotehash, 2, $timezone);
    if(!$separator) { $separator = "\n "; }
  }
  return "($resultstr)\n";
}

sub get_exchange_timezone {
  my($exchange) = @_;
  my $tz;
  $exchange = lc($exchange);
  
  if($exchange eq "nasdaq") {
    $tz = 'EST';
  } elsif ($exchange eq "nyse") {
    $tz = 'EST';    
  } else {
    return undef;
  }
}

sub parse_input_line {

  # FIXME: we need to rewrite parsing to handle commands modularly.
  # Right now all we do is hard-code "fetch".

  my($input) = @_;
  # Have to do this because the perl-mode parser freaks out otherwise.
  my $dq = '"';
  my $exchange;
  my @items;

  # Make sure we have an opening ( preceeded only by whitespace.
  # and kill it off if we do...
  if($input !~ s/^\s*\(\s*fetch\s+//o) { return 0; }

  # Make sure we have an ending ) followed only by whitespace
  # and kill it off if we do...
  if($input !~ s/\s*\)\s*$//o) { return 0; }
  
  # Now grab the exchange.
  if($input !~ /^$dq([^$dq]+)$dq\s*/o) { return 0; }
  
  $exchange = $1;
  $input = $POSTMATCH;

  # Now grab all the items.
  while($input) {
    if($input !~ /^$dq([^$dq]+)$dq\s*/o) { return 0; }
    
    my $item = $1;
    push @items, $item;
    $input = $POSTMATCH;
  }

  my @result = ($exchange, \@items);
  return \@result;
}

#---------------------------------------------------------------------------
# Runtime.

# Create a stockquote object.
my $quoter = Finance::Quote->new();
my $prgnam = "scmio-finance-quote";

# Make sure USD is the default.
$quoter->set_currency("USD");

while(<>) {

  my $result = parse_input_line($_);

  if(!$result) {
    print STDERR "$prgnam: bad input line ($_)\n";
    exit 1;
  }

  my($exchange, $items) = @$result;

  my $quote_data = $quoter->fetch($exchange, @$items);

  if(!$quote_data) {
    print "#f\n";
    exit 1;
  }

  my $zone = get_exchange_timezone($exchange);
  print schemify_quotes(\@$items, $quote_data, $zone);
  STDOUT->flush();
}

exit 0;

__END__

## Local Variables:
## mode: perl
## End:
