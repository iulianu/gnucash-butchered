/********************************************************************\
 * checkpoint.c : computes account balance checkpoints              *
 * Copyright (C) 2001 Linas Vepstas <linas@linas.org>               *
 *                                                                  *
 * This program is free software; you can redistribute it and/or    *
 * modify it under the terms of the GNU General Public License as   *
 * published by the Free Software Foundation; either version 2 of   *
 * the License, or (at your option) any later version.              *
 *                                                                  *
 * This program is distributed in the hope that it will be useful,  *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of   *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    *
 * GNU General Public License for more details.                     *
 *                                                                  *
 * You should have received a copy of the GNU General Public License*
 * along with this program; if not, contact:                        *
 *                                                                  *
 * Free Software Foundation           Voice:  +1-617-542-5942       *
 * 59 Temple Place - Suite 330        Fax:    +1-617-542-2652       *
 * Boston, MA  02111-1307,  USA       gnu@gnu.org                   *
\********************************************************************/

/* 
 * FILE:
 * checkpoint.c
 *
 * FUNCTION:
 * Account balance checkpointing.
 * Not used in single-user mode; vital for multi-user mode.
 *
 * HISTORY:
 * Copyright (c) 2000, 2001 Linas Vepstas
 * 
 */

#define _GNU_SOURCE
#include <glib.h>
#include <stdio.h>  
#include <string.h>  
#include <sys/types.h>  

#include <libpq-fe.h>  

#include "Account.h"
#include "AccountP.h"
#include "Backend.h"
#include "BackendP.h"
#include "Group.h"
#include "gnc-commodity.h"
#include "gnc-engine-util.h"
#include "guid.h"
#include "GNCId.h"
#include "GNCIdP.h"

#include "builder.h"
#include "PostgresBackend.h"

#include "putil.h"

static short module = MOD_BACKEND; 

/* ============================================================= */
/* include autogenerated code */

#include "check-autogen.c"

/* ============================================================= */
/* recompute *all* checkpoints for the account */

static void
pgendAccountRecomputeAllCheckpoints (PGBackend *be, const GUID *acct_guid)
{
   Timespec this_ts, next_ts;
   GMemChunk *chunk;
   GList *node, *checkpoints = NULL;
   PGresult *result;
   Checkpoint *bp;
   char *p;
   int i, nrows, nsplits;
   int nck;
   Account *acc;
   const char *commodity_name, *guid_string;

   if (!be) return;
   ENTER("be=%p", be);

   guid_string = guid_to_string (acct_guid);
   acc = xaccLookupEntity (acct_guid, GNC_ID_ACCOUNT);
   commodity_name = gnc_commodity_get_unique_name (xaccAccountGetCommodity(acc));

   chunk = g_mem_chunk_create (Checkpoint, 300, G_ALLOC_ONLY);

   /* prevent others from inserting any splits while we recompute 
    * the checkpoints. (hack alert -verify that this is the correct
    * lock) */
   p = "BEGIN WORK; "
       "LOCK TABLE gncCheckpoint IN ACCESS EXCLUSIVE MODE; "
       "LOCK TABLE gncEntry IN SHARE MODE; ";
   SEND_QUERY (be,p, );
   FINISH_QUERY(be->connection);

   /* Blow all the old checkpoints for this account out of the water.
    * This should help ensure against accidental corruption.
    */
   p = be->buff; *p = 0;
   p = stpcpy (p, "DELETE FROM gncCheckpoint WHERE accountGuid='");
   p = guid_to_string_buff (acct_guid, p);
   p = stpcpy (p, "';");
   SEND_QUERY (be,be->buff, );
   FINISH_QUERY(be->connection);

   /* malloc a new checkpoint, set it to the dawn of unix time ... */
   bp = g_chunk_new0 (Checkpoint, chunk);
   checkpoints = g_list_prepend (checkpoints, bp);
   this_ts = gnc_iso8601_to_timespec_local (CK_EARLIEST_DATE);
   bp->date_start = this_ts;
   bp->account_guid = acct_guid;
   bp->commodity = commodity_name;

   /* loop over entries, creating a set of evenly-spaced checkpoints */
   nck = MIN_CHECKPOINT_COUNT;
   while (1)
   {
      p = be->buff; *p = 0;
      p = stpcpy (p, "SELECT gncTransaction.date_posted"
                     "    FROM gncTransaction, gncEntry"
                     "    WHERE"
                     "        gncEntry.transguid = gncTransaction.transguid AND"
                     "        gncEntry.accountguid='");
      p = stpcpy (p, guid_string);
      p = stpcpy (p, "'"
                     "    ORDER BY gncTransaction.date_posted ASC"
                     "    LIMIT 2 OFFSET ");
      p += sprintf (p, "%d", nck);
      p = stpcpy (p, ";");
      SEND_QUERY (be,be->buff, );

      i=0; 
      do {
         GET_RESULTS (be->connection, result);
         {
            int j, jrows;
            int ncols = PQnfields (result);
            jrows = PQntuples (result);
            PINFO ("query result %d has %d rows and %d cols",
               i, jrows, ncols);

            if (0 == jrows) {
                FINISH_QUERY(be->connection);
                goto done; 
            }

            if (0 == i) this_ts = gnc_iso8601_to_timespec_local (DB_GET_VAL("date_posted",0));
            if (2 == jrows) {
               next_ts = gnc_iso8601_to_timespec_local (DB_GET_VAL("date_posted",1));
            } else if (1 == i) {
               next_ts = gnc_iso8601_to_timespec_local (DB_GET_VAL("date_posted",0));
            } 
            PQclear (result);
            i++;
         }
      } while (result);

      /* lets see if its time to start a new checkpoint */
      /* look for splits that occur at least ten seconds apart */
      this_ts.tv_sec += 10;
      if (timespec_cmp (&this_ts, &next_ts) < 0)
      {
         /* Set checkpoint five seconds back. This is safe,
          * because we looked for a 10 second gap above */
         this_ts.tv_sec -= 5;
         bp->date_end = this_ts;

         /* and build a new checkpoint */
         bp = g_chunk_new0 (Checkpoint, chunk);
         checkpoints = g_list_prepend (checkpoints, bp);
         bp->date_start = this_ts;
         bp->account_guid = acct_guid;
         bp->commodity = commodity_name;
         nck += MIN_CHECKPOINT_COUNT;
      }
      else 
      {
         /* step one at a time until we find at least a ten-second gap */
         nck += 1;
      }
   }

done:

   /* set the timestamp on the final checkpoint into the distant future */
   this_ts = gnc_iso8601_to_timespec_local (CK_LAST_DATE);
   bp->date_end = this_ts;

   /* now store the checkpoints */
   for (node = checkpoints; node; node = node->next)
   {
      bp = (Checkpoint *) node->data;
      pgendStoreOneCheckpointOnly (be, bp, SQL_INSERT);
   }

   g_list_free (checkpoints);
   g_mem_chunk_destroy (chunk);

   /* finally, let the sql server do the heavy lifting of computing the 
    * subtotal balances */
   p = be->buff; *p = 0;
   p = stpcpy (p, "UPDATE gncCheckpoint SET "
                  "  balance            = (gncsubtotalbalance        (accountGuid, date_start, date_end )),"
                  "  cleared_balance    = (gncsubtotalclearedbalance (accountGuid, date_start, date_end )),"
                  "  reconciled_balance = (gncsubtotalreconedbalance (accountGuid, date_start, date_end )) "
                  "WHERE accountGuid='");
   p = stpcpy (p, guid_string);
   p = stpcpy (p, "'; ");
   p = stpcpy (p, "COMMIT WORK;");
   SEND_QUERY (be,be->buff, );
   FINISH_QUERY(be->connection);

   g_free ((gpointer) guid_string);
}

/* ============================================================= */
/* recompute fresh balance checkpoints for every account */

void
pgendGroupRecomputeAllCheckpoints (PGBackend *be, AccountGroup *grp)
{
   GList *acclist, *node;

   acclist = xaccGroupGetSubAccounts(grp);
   for (node = acclist; node; node=node->next)
   {
      Account *acc = (Account *) node->data;
      pgendAccountRecomputeAllCheckpoints (be, xaccAccountGetGUID(acc));
   }
   g_list_free (acclist);
}

/* ============================================================= */
/* get checkpoint value for the account 
 * We find the checkpoint which matches the account and commodity,
 * for the first date immediately preceeding the date.  
 * Then we fill in the balance fields for the returned query.
 */

static void
pgendAccountGetCheckpoint (PGBackend *be, Checkpoint *chk)
{
   PGresult *result;
   int i, nrows;
   char * p;

   if (!be || !chk) return;
   ENTER("be=%p", be);

   /* create the query we need */
   p = be->buff; *p = 0;
   p = stpcpy (p, "SELECT sum(balance) AS baln, "
                  "       sum(cleared_balance) AS cleared_baln, "
                  "       sum(reconciled_balance) AS reconed_baln "
                  "    FROM gncCheckpoint "
                  "    WHERE accountGuid='");
   p = guid_to_string_buff (chk->account_guid, p);
   p = stpcpy (p, "'   AND commodity='");
   p = stpcpy (p, chk->commodity);
   p = stpcpy (p, "'   AND date_end <'");
   p = gnc_timespec_to_iso8601_buff (chk->date_end, p);
   p = stpcpy (p, "';");
   SEND_QUERY (be,be->buff, );

   i=0; nrows=0;
   do {
      GET_RESULTS (be->connection, result);
      {
         int j=0, jrows;
         int ncols = PQnfields (result);
         jrows = PQntuples (result);
         nrows += jrows;
         PINFO ("query result %d has %d rows and %d cols",
            i, nrows, ncols);

         if (1 < nrows) 
         {
            PERR ("excess data");
            PQclear (result);
            return;
         }
         if (0 < nrows )
         {
            chk->balance = atoll(DB_GET_VAL("baln", j));
            chk->cleared_balance = atoll(DB_GET_VAL("cleared_baln", j));
            chk->reconciled_balance = atoll(DB_GET_VAL("reconed_baln", j));
         }
      }

      PQclear (result);
      i++;
   } while (result);

   LEAVE("be=%p", be);
}

/* ============================================================= */
/* get checkpoint value for one accounts */

void
pgendAccountGetBalance (PGBackend *be, Account *acc, gint64 as_of_date)
{
   Checkpoint chk;
   const gnc_commodity *com;
   gint64 deno;
   gnc_numeric baln;
   gnc_numeric cleared_baln;
   gnc_numeric reconciled_baln;

   if (!be || !acc) return;
   ENTER("be=%p", be);

   /* setup what we will match for */
   chk.date_end.tv_sec = as_of_date;
   chk.date_end.tv_nsec = 0;

   com = xaccAccountGetCommodity(acc);
   chk.commodity = gnc_commodity_get_unique_name(com);
   chk.account_guid = xaccAccountGetGUID (acc);
   chk.balance = 0;
   chk.cleared_balance = 0;
   chk.reconciled_balance = 0;

   /* get the checkpoint */
   pgendAccountGetCheckpoint (be, &chk);

   /* set the account balances */
   deno = gnc_commodity_get_fraction (com);
   baln = gnc_numeric_create (chk.balance, deno);
   cleared_baln = gnc_numeric_create (chk.cleared_balance, deno);
   reconciled_baln = gnc_numeric_create (chk.reconciled_balance, deno);

   xaccAccountSetStartingBalance (acc, baln,
                                     cleared_baln, reconciled_baln);
   LEAVE("be=%p", be);
}

/* ============================================================= */
/* get checkpoint value for all accounts */

void
pgendGroupGetAllBalances (PGBackend *be, AccountGroup *grp, 
                             gint64 as_of_date)
{
   GList *acclist, *node;

   if (!be || !grp) return;
   ENTER("be=%p", be);

   /* loop over all accounts */
   acclist = xaccGroupGetSubAccounts (grp);
   for (node=acclist; node; node=node->next)
   {
      Account *acc = (Account *) node->data;
      pgendAccountGetBalance (be, acc, as_of_date);
   }

   g_list_free (acclist);
   LEAVE("be=%p", be);
}

/* ======================== END OF FILE ======================== */
