
Accounting Engine
-----------------

Quick Overview
--------------
The fundamental accounting unit is a "split". Each split stores
a (monetary) value, a memo, and a pointer to the "credited" account.
The term "credited" here is arbitrary, as the value can be 
positive or negative.

The notion of "double entry" is embodied in the "transaction" structure.
The transaction consists of a date, a single "source split" and zero
or more "destination splits".  Again, the notion of "source" and
"destination" are arbitrary, as the value stored in the split can be 
positive or negative.

If a transaction has one or more "dest_splits", then the sum of 
the destination-split values *must* equal the value of the source-split.
This equality is what forces a double-entry accounting system to
balance.

A transaction may have zero "destination-splits".  If the transaction value
is non-zero, then by definition, the system as a whole cannot balance.
Many simple, home-oriented non-double-entry systems will allow
non-balancing transactions, as these are simpler to comprehend for the 
casual home user.

Every split must point at its parent transaction, and that transaction
must in turn point back at the split.   A split can belong to at most
one transaction.

Splits are grouped into "accounts". Each account consists of a list of 
splits that credit (debit) that account.   To ensure consistency, 
if a split points at an account, then the account must point at the 
split, and vice-versa.  A split can belong to at most one account.

Accounts can be arranged in a heirarchical tree.  The nodes of the 
tree are called "Account Groups".  By accounting convention, the 
value of an account is equal to the value of all of its splits plus
the value of all of its sub-accounts.  Account Groups are implemented 
as doubly-linked trees.


Stocks, non-Currency-Denominated Assets
---------------------------------------
The engine includes support for non-currency-denominated assets, 
such as stocks, bonds, mutual funds, inventory.  This is done with
two values in the Split structure:

   double share_price;
   double damount;

"damount" is the number of shares/items.  It is an "immutable" quantity,
in that it cannot change except by transfer (sale/purchase).  It is the
quantity that is used when computing balances.

"share_price" is the price of the item in question.  The share-price is
of course subject to fluctuation.

The net-value of a split is the product of "damount" and "share_price".
The currency balance of an account is the sum of all "damounts" times
the latest, newest share-price.

Currency accounts should use a share price of 1.0 for all splits.

To maintain the double-entry consistency, one must have the following
hold true:

   0.0 == 
   (source_split->damount) * (source_split->share_price) +
   sum of all ((dest_split->damount) * (dest_split->share_price))  

Thus, for example, the purchase of shares can be represented as:

   source:
   debit ABC Bank for $1045  (1045 dollars * dollar "price" of 1.00)
   
   destination:
   credit PQR Stock for $1000 (100 shares at $10 per share)
   credit StockBroker category $45 in fees


Error Reporting
---------------
The error reporting architecture (partially implemented), uses a globally
visible subroutine to return an error.  In the naivest possible implementation,
the error reporting mechanism would look like this:

    int error_num;   /* global error number */

    int xaccGetError (void) { return error_num; }

    void xaccSomeFunction (Args *various_args) {
        if (bad_thing_happened) error_num = 42;
    }  

Many programmers are used to a different interface, e.g.

    int xaccSomeFunction (Args *various_args) {
        if (bad_thing_happened) return (42);
    }  

Because of this, it is important to explain why the former design was choosen over
the latter.  Let us begin by listing how the choosen design is as good as, and in
many ways can be better to the later design.

 (1) Allows programmer to check for errors asynchronously, e.g. outside
     of a performance critical loop, or far away, after the return of
     several subroutines.
 (2) (with the right implementation) Allows reporting of multiple, complex
     errors.  For example, it can be used to implement a trace mechanism.
 (3) (with the right implementation) Can be thread safe.
 (4) Allows errors that occurred deep in the implementation to be reported
     up to much higher levels without requireing bagagge inthe middle.

The right implementation for (2) is to implement not a single variable, but a stack
or a ring (circular queue) on which error codes are placed, and from which error
codes can be retreived.  The right implementation for (3) is the use
pthread_getspecific() to define a per-thread global and/or ring/queue.


Engine Isolation
----------------
Some half-finished thoughts about the engine API:

-- The engine structures should not be accessible to any code outside of the engine.
   Thus, the engine structures have been moved to AccountP.h, TransactionP.h, etc.
   The *P.h files should not be included by code outside of the engine.

-- The goal of hiding the engine internals behind an API is to allow the engine 
   to be replaced by a variety of back ends, e.g. an SQL and/or CORBA back-end.

-- The down-side of hiding is that it can hurt performance.  Even trivial data 
   accesses require a subroutine call.  Maybe a smarter idea would be to leave
   the structures exposed, allow direct manipulation, and then "copy-in" and
   "copy-out" the structures into parallel structures when a hidden back end
   needs to be invoked.

-- the upside of hiding behind an API is that the engine can be instrumented
   with extension language (perl, scheme, tcl, python) hooks for pre/post processing
   of the data.  To further enable such hooks, we should probably surround all
   operations on structures with "begin-edit" and "end-edit" calls.

-- begin/end braces could potentially be useful for two-phase commit schemes.
   where "end-edit" is replaced by "commeit-edit" or "reject-edit".


Reconciliation
--------------
> * From: "Christopher B. Browne" <cbbrowne@knuth.brownes.org>
> >
> > /* Values for the reconciled field in Transaction: */
> > #define CREC 'c'              /* The transaction has been cleared
> > */
> > #define YREC 'y'              /* The transaction has been reconciled
> > */
> > #define FREC 'f'              /* frozen into accounting period
> > */
> > #define NREC 'n'              /* not reconciled or cleared
> > */

Note that FREC is not yet used/implemented ...

>  I've reconciled the bank/credit card                                   
> statement containing the transaction, and completed the
> reconciliation.  One
> could consider the transaction to now be "set in stone."  

If a transaction has been marked "reconciled" in the gui, should
the GUI then block any changes to the transaction?

How about the following proposal:
-- transactions marked 'y' (reconciled) in gui cannot be edited.
-- gui will allow 'y' to be changed back to 'n' or 'c'
   (thus allowing editing).
-- engine will also enforce above restricitions
-- transactions marked 'f' cannot be changed, period, either
   in the gui or the engine.

Let me know if this is a bad idea, otherwise I'll implement it.


> (In a more traditional accounting system, this would be very much 
> the case.  Once a period is "closed," you can't change the data 
> anymore...)



Remaining Work Items
--------------------
The date handling functions need to be replaced with something that
handles time, down to milliseconds.  I know millisecssounds stupid, but
big banks use this for various consistency reasons.



March 1998
