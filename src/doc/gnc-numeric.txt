API documentation for gnc-numeric
---------------------------------

The gnc_numeric API provides data types and functions for manipulating
exact numeric quantities.  gnc_numeric was developed to represent and
operate on exact financial quantities in gnucash, but it is
(hopefully) suitable for use in most places an exact numeric
representation for non-integer numbers is needed.

gnc_numeric represents numbers in a rational form, with a 64-bit 'long
long' integer as numerator and denominator.  If more precision is
needed, or a higher-precision representation of irrational numbers, or
a wider dynamic range, a floating point format may be appropriate.
There are reasonable rational approximations to common irrational
constants [1], but the transcendental functions have not been
implemented for gnc_numeric objects.

1. Standard arguments 

It is useful to specify a denominator in cases where it is known that
the output value is of constrained precision.  For example, monetary
transactions must be executed in an integer number of the "smallest
currency unit" of the transaction.  In US Dollars, the smallest
currency unit is the cent, and all monetary transactions must be done
in units of cents.  Therefore, any fractional cents in a computed
price must be rounded away.

Most of the gnc_numeric arithmetic functions take two arguments in
addition to their numeric args: 'denom', which is the denominator to
use in the output gnc_numeric object, and 'how', which describes how
the arithmetic result is to be converted to that denominator.  This
combination of output denominator and rounding policy allows the
results of financial and other exact computations to be properly
rounded to the appropriate units.

Valid values for 'denom' are:

   n (positive int)           Use the number 'n' as the denominator of the 
                              output value.
   GNC_DENOM_RECIPROCAL( n )  Use the value '1/n' as the denominator of 
                              the output value.  
   GNC_DENOM_AUTO             Compute an appropriate denominator
                              automatically.  Flags in the 'how'
                              argument will specify how to compute the
                              denominator.
   
Valid values for 'how' are bitwise combinations of zero or one
"rounding instructions" with zero or one "denominator types". 

Rounding instructions control how fractional parts in the specified
denominator affect the result.  For example, if a computed result is
"3/4" but the specified denominator for the return value is 2, should
the return value be "1/2" or "2/2"?  

Possible rounding instructions are:
  GNC_RND_FLOOR   : round toward -infinity
  GNC_RND_CEIL    : round toward +infinity
  GNC_RND_TRUNC   : truncate fractions (round toward zero)
  GNC_RND_PROMOTE : promote fractions (round away from zero)
  GNC_RND_ROUND   : use unbiased ("banker's") rounding.  This rounds 
                    to the nearest integer, and to the nearest even 
                    integer when there are two equidistant nearest 
                    integers. 
  GNC_RND_ROUND_HALF_UP : round to the nearest integer, rounding away
                    from zero when there are two equidistant nearest 
                    integers. 
  GNC_RND_ROUND_HALF_DOWN : round to the nearest integer, rounding toward
                    zero when there are two equidistant nearest 
                    integers. 
  GNC_RND_NEVER   : never round at all, and signal an error if there is a
                    fractional result in a computation. 
                    
The denominator type specifies how to compute a denominator if
GNC_DENOM_AUTO is specified as the 'denom'.  Valid denominator types
are:

  GNC_DENOM_EXACT : Use any denominator which gives an exactly correct
                    ratio of numerator to denominator.  Use EXACT when
                    you do not wish to lose any information in the result
                    but also do not want to spend any time finding the 
                    "best" denominator. 
  GNC_DENOM_REDUCE : Reduce the result value by common factor elimination,
                    using the smallest possible value for the denominator
                    that keeps the correct ratio.  The numerator and 
                    denominator of the result are relatively prime.
                    This can be computationally expensive for large 
                    fractions. 
  GNC_DENOM_LCD   : Find the least common multiple of the arguments'
                    denominators and use that as the denominator of the
                    result.
  GNC_DENOM_FIXED : All arguments are required to have the same denominator, 
                    that denominator is to be used in the output, and 
                    an error is to be signaled if any argument has a 
                    different denominator.

To use traditional rational-number operational semantics (all results
are exact and are reduced to relatively-prime fractions) pass the
argument GNC_DENOM_AUTO as 'denom' and GNC_DENOM_REDUCE | GNC_RND_NEVER 
as 'how'.

To enforce strict financial semantics (such that all operands must
have the same denominator as each other and as the result), use
GNC_DENOM_AUTO as 'denom' and GNC_DENOM_FIXED | GNC_RND_NEVER as
'how'.


2. Creating gnc-numeric objects

   gnc_numeric_create(int num, int denom);   
      Create a gnc_numeric object with a value of "num / denom".

   gnc_numeric_zero();
      Create a gnc_numeric object with a value of 0. 

3. Basic arithmetic operations

   See 'Standard arguments' for a description of the 'denom' and 'how'
   arguments to each arithmetic function.
   
   gnc_numeric gnc_numeric_add(gnc_numeric b, gnc_numeric b,
                               gint64 denom, gint how);
     Add.

   gnc_numeric gnc_numeric_sub(gnc_numeric b, gnc_numeric b,
                               gint64 denom, gint how);
     Subtract.

   gnc_numeric gnc_numeric_mul(gnc_numeric b, gnc_numeric b,
                               gint64 denom, gint how);
     Multiply.

   gnc_numeric gnc_numeric_div(gnc_numeric b, gnc_numeric b,
                               gint64 denom, gint how);
     Divide.

   gnc_numeric gnc_numeric_neg(gnc_numeric a);
     Negate. 

4. Arithmetic operations with error returns

   These functions perform the same operation as the corresponding
   non-"with_error" function, but additionally fill in the
   "error" argument with a "remainder" value indicating the
   exact difference between the function's return value and a
   GNC_DENOM_FIXED version of the same call.  This is a way of
   accumulating the "fractional pennies" that can be rounded or
   truncated in normal arithmetic operations.

    gnc_numeric gnc_numeric_add_with_error(gnc_numeric a, gnc_numeric b,
	                                   gint64 denom, gint how,
                                           gnc_numeric * error);
    gnc_numeric gnc_numeric_sub_with_error(gnc_numeric a, gnc_numeric b,
                                           gint64 denom, gint how,
                                           gnc_numeric * error);
    gnc_numeric gnc_numeric_mul_with_error(gnc_numeric a, gnc_numeric b,
                                           gint64 denom, gint how,
                                           gnc_numeric * error);
    gnc_numeric gnc_numeric_div_with_error(gnc_numeric a, gnc_numeric b,
                                           gint64 denom, gint how,
                                           gnc_numeric * error);

5. Comparisons and predicates 

    int gnc_numeric_zero_p(gnc_numeric a);
      Returns 1 if a == 0, 0 else. 

    int gnc_numeric_positive_p(gnc_numeric a);
      Returns 1 if a>0, 0 else.

    int gnc_numeric_negative_p(gnc_numeric a);
      Returns 1 if a>0, 0 else.

    int gnc_numeric_compare(gnc_numeric a, gnc_numeric b);
      Returns +1 if a>b, -1 if b>a, 0 if a == b.

    Equality predicates: 
    
    int gnc_numeric_eq(gnc_numeric a, gnc_numeric b);
      Returns 1 if numerator(a) == numerator(b) &&
      denominator(a) == denominator(b), 0 else.

    int gnc_numeric_equal(gnc_numeric a, gnc_numeric b);
      Returns 1 if the fraction represented by a is equal to 
      the fraction represented by b, 0 else.  

    int gnc_numeric_same(gnc_numeric a, gnc_numeric b, gint64 denom,
                         gint how);
      Convert both 'a' and 'b' to 'denom' (standard args) and 
      compare numerators of the result.  

      For example, if a == "7/16" and b == "3/4",
        gnc_numeric_same(a, b, 2, GNC_RND_TRUNC) == 1 because both 
      7/16 and 3/4 round to 1/2 under truncation.  However,
        gnc_numeric_same(a, b, 2, GNC_RND_ROUND) == 0 because 
      7/16 rounds to 1/2 under unbiased rounding but 3/4 rounds to 
      2/2.  

6. Denominator conversion

   gnc_numeric_convert(gnc_numeric in, gint64 denom, gint how);
     Convert the input value to the specified denominator under 
     standard arguments 'denom' and 'how'.

   gnc_numeric_convert_with_error(gnc_numeric in, gint64 denom, 
                                  gint how, gnc_numeric * error);
     Same as gnc_numeric_convert, but return a remainder value for
     accumulating conversion error.  


7. Floating point conversion

   double_to_gnc_numeric(double arg, gint64 denom, gint how);
      Convert a floating-point number to a gnc_numeric.  'denom'
      and 'how' are used as in arithmetic, but GNC_DENOM_AUTO is 
      not recognized.    

   gnc_numeric_to_double(gnc_numeric arg);

8. Error handling 

   int gnc_numeric_check(num)
      Check 'num' for the possibility that it is an error signal 
      rather than a proper value.  Possible return codes are 
      0 (GNC_ERROR_OK, or no error condition), or 
     
      GNC_ERROR_ARG         An improper argument was passed to a function
      GNC_ERROR_OVERFLOW    An overflow occurred while calculating a result 
      GNC_ERROR_DENOM_DIFF  GNC_DENOM_FIXED was specified, but argument 
                            denominators differed. 
      GNC_ERROR_REMAINDER   GNC_RND_NEVER was specified, but the result
                            could not be converted to the desired 
                            denominator without a remainder. 

   gnc_numeric gnc_numeric_error(err);
      Create a gnc_numeric object that signals the error condition
      noted by 'err' rather than a number.  


[1] The following program finds the best gnc_numeric approximation to
the math.h constant M_PI given a maximum denominator.  For large
denominators, the gnc_numeric approximation is accurate to more
decimal places than will generally be needed, but in some cases this
may not be good enough.  For example, 

    M_PI                   = 3.14159265358979323846
    245850922 / 78256779   = 3.14159265358979311599  (16 sig figs)
    3126535 / 995207       = 3.14159265358865047446  (12 sig figs)
    355 / 113              = 3.14159292035398252096  (7 sig figs)

------------------------------------

#include <glib.h>
#include "gnc-numeric.h"
#include <math.h>

int
main(int argc, char ** argv) {
  gnc_numeric approx, best;
  double err, best_err=1.0;
  double m_pi = M_PI;
  gint64 denom;
  gint64 max;

  sscanf(argv[1], "%Ld", &max);
  
  for(denom = 1; denom < max; denom++) {
    approx = double_to_gnc_numeric(m_pi, denom, GNC_RND_ROUND);
    err    = m_pi - gnc_numeric_to_double(approx);
    if(fabs(err) < fabs(best_err)) {
      best = approx;
      best_err = err;
      printf("%Ld / %Ld = %.30f\n", gnc_numeric_num(best),
             gnc_numeric_denom(best), gnc_numeric_to_double(best));
    }
  }
  exit(0);
}
  
  

